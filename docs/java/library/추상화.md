## 추상화(Abstract, Interface)
- 구현이 아닌, 역할 중심으로 설계를 하여 변경에 강하고, 확장에 유연한 구조를 만들기 위해 사용 **`OCP`(Open–Closed Principle)원칙**

### 목적
- 변경 가능성이 높은 구현을 분리
- 호출자는 역할만 의존하도록 설계
- 기능 확장은 기존 코드 수정 없이 가능

### 기능
- 코드 확장성 향상
- 구현 은닉
- 다형성 기반 단순화
- 중복 코드 제거

## 인터페이스 VS 추상 클래스

### 인터페이스
- 역할(행위의 계약) 정의
- 다중 구현 가능
- 상태(필드) 없음
- 현대 객체지향 설계의 기본 선택지

### 추상 클래스
- 역할 + 일부 구현 제공
- 단일 상속만 가능
- 상태(필드) 보유 가능

### 선택 기준 (실무 기준)
**인터페이스를 더 많이 사용하는 이유**
1. 상속은 결합도가 매우 강함
2. 인터페이스는 역할만 강제
3. SOLID 원칙은 인터페이스 중심 설계
4. 구현 교체 및 테스트 용이

### 추상 클래스는 언제 사용하는가?
- 명확한 is-a 관계가 존재
- 공통 상태(필드)가 필요
- 공통 로직의 비중이 큼
- 계층 구조가 비교적 안정적일 때

## is-a / has-a

### is-a 관계 (상속)
- A is a B
- A는 B의 한 종류
- 상속 관계
```markdown
모닝은 자동차이다.
```

### has-a 관계 (합성)
- A has a B
- A는 B를 포함
- 합성(Composition) 관계
```markdown
자동차는 엔진이 있다.
```

## 주의사항

### 다중 상속 문제
- 클래스는 다중 상속 불가
  - 다이아몬드 문제 발생 가능
    - 어느 부모 메서드를 호출해야 하는지 알 수 없다.
- 인터페이스는 다중 구현 가능
  - 구현 책임은 자식 클래스에 있음

### Java 8 이후 인터페이스 변화
- `default method` 도입
  - 구현 제공 가능
  - 오버라이드 가능
- `default method`로 문제
  - 인터페이스에서도 다이아몬드 문제가 발생 가능
  - 충돌 시 구현 클래스에서 반드시 명시적 해결 필요