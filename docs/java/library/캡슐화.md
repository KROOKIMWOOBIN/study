## 캡슐화
- 객체의 내부 상태와 구현을 외부로부터 숨기는 것
- 객체는 행동(메서드) 을 통해서만 사용된다
```java
class User {
    
    private int age;

    public int getAge() {
        return age;
    }
    
    public void increaseAge() {
        age++;
    }
    
}
```

### 목적
- 외부는 무엇을 하는지만 알면 된다.
  - 어떻게 하는지는 몰라도 됨
```markdown
user.increaseAge(); // 내부에서 age++
```
- 외부에서 age++ 직접 못 하게 막음
- 변경 포인트를 클래스 내부로 한정

### 왜 샤옹하는가?

#### 사용하지 않는 경우
1. 변경이 시스템 전체로 퍼진다.
   - 필드에 직접 접근하여 어디서든 수정이 가능하다.
2. 상태가 깨져도 막을 수 없다.
   - 객체 외부에서 잘못된 값 대입 가능
3. 책임이 객체 밖으로 새어 나간다.
   - 상태 변경 규칙이 호출자마다 분산됨

#### 사용하는 경우
1. 변경 지점을 한 곳으로 모은다.
   - 규칙 변경 → 이 메서드만 수정
   - 외부 영향 최소화
```markdown
public void increaseAge() {
    if (age > 100) {
        System.out.println("100살보다 나이가 많아질 수 없습니다.");
        return;
    }
    age++;
}
```
2. 객체가 자신의 상태를 책임진다.
- 외부는 요청만 함
- 객체는 검증 + 변경을 스스로 처리
```markdown
user.increaseAge();
```
3. 내부 구현을 바꿔도 외부는 안 바뀐다.
```markdown
private int age; -> private LocalDate birthDate;
```

## 접근 제어자
| 제어자       | 범위       |
|-----------|----------|
| private   | 클래스 내부   |
| default   | 패키지      |
| protected | 패키지 + 상속 |
| public    | 전체       |