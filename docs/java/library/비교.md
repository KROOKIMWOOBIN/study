## Comparable, Comparator
- 객체에 필드를 비교하기 위해서 구현해줘야 한다. 만약 Comparable, Comparator 둘 다 구현하지 않고 객체에 비교를 시도하면 ClassCastException이 발생한다.

### Comparable
- [비교 가능한]이라는 뜻이다.
- 객체 자신이 가지는 기본 정렬 기준(natural ordering) 을 정의한다.
- “이 타입은 이렇게 정렬되는 것이 기본이다”를 명시

### Comparator
- [비교자]라는 뜻이다.
- 객체 외부에서 정의하는 정렬 전략
- 상황·화면·정책에 따라 정렬 기준을 바꿀 수 있음

### Tree
- Tree 구조는 객체를 넣으면 비교할 수 있도록 [비교 가능한] 또는 [비교자]가 필수이다.
- [비교 가능한] 또는 [비교자]를 구현하지 않으면 에러가 발생한다.

### 예제
```java
public class Main {
    public static void main(String[] args) {
        Member member1 = new Member("A", 10);
        Member member2 = new Member("B", 20);
        Member[] members = {member1, member2};
        Arrays.sort(members); // 멤버 인스턴스에 기본 정렬(compareTo)를 기반으로 정렬
        Arrays.sort(members, new AgeComparator()); // 정렬 방법 지정 가능
        
        // 컬렉션 정렬
        List<Member> list = List.of(member1, member2);
        // 기본 정렬
        list.sort(null);
        // Collections.sort(list);
        // 정렬 지정
        list.sort(new AgeComparator());
        // Collections.sort(list, new AgeComparator());

        Set<MyUser> treeSet1 = new TreeSet<>(); // Tree는 기본 정렬이 자동으로 된다.
        Set<MyUser> treeSet2 = new TreeSet<>(new IdComparator()); // 정렬 기준을 지정할 수 있다.
    }
}
@Getter
class Member implements Comparable<Member> {
    String name;
    int age;
    Member(String name, int age) {
        this.name = name;
        this.age = age;
    }
    @Override
    public int compareTo(Member o) {
        return this.name.compareTo(o.name);
    }
}
class AgeComparator implements Comparator<Member> {
    @Override
    public int compare(Member o1, Member o2) {
        return o1.getAge().compareTo(o2.getAge());
    }
}
```