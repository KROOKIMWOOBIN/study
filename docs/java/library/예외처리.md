## 예외처리
### 예외 계층 구조
- Object
  - Throwable
    - Error
      - 시스템 에러
      - 애플리케이션에서 복구가 불가능한 시스템 예외이다.
      - 애플리케이션 개발자는 이 예외를 잡으려고 해서는 안된다.
      - OutOfMemoryError
    - Exception
      - 애플리케이션 로직에서 사용할 수 있는 실질적인 최상위 예외이다.
      - 체크 예외
        - 개발자가 실수로 예외를 누락하지 않도록 컴파일러를 통해 문제를 잡아주는 안전 장치이다.
      - 개발자가 모든 체크 예외를 반드시 잡거나 던지도록 처리해야 하기 때문에, 크게 신경쓰고 싶지 않은 예외까지 모두 챙겨야 한다.
      - 컴파일 레벨에서 체크한다.
      - Exception 상속 받으면 체크 예외가 된다.
        - SQLException
        - IOException
    - RunTimeException
      - Exception에 자식
      - 언체크 예외
      - 장점
        - 신경쓰고 싶지 않은 언체크 예외를 무시할 수 있다.
      - 단점
        - 개발자가 실수로 예외를 누락할 수 있다.
      - 컴파일러가 체크 하지 않는 언체크 예외이다.
      - 런타임 에러와 그 하위 에러를 런타임 예외라고 많이 부른다.
      - RunTimeException 상속 받으면 언체크 예외가 된다.
        - NullPointerException
        - IllegalArgumentException
      - throws 키워드를 생략할 수 있다.
### 예외 기본 규칙
- 예외는 잡아서 처리하거나, 밖으로 던져야 한다.
- 예외를 잡거나 던질 때, 지정한 예외뿐 아니라 그 예외의 자식들도 함께 처리할 수 있다.
  - Exception catch 잡으면 그 하위 예외도 모두 잡을 수 있다.
  - Exception throws 던지면 그 하위 예외도 모두 던질 수 있다.
### 예외
- try
  - 정상 흐름
- catch
  - 예외 흐름
- finally
  - 반드시 호출해야 하는 마무리 흐름
### try-with-resources
- 자바7에서 돌입
- AutoCloseable 인터페이스 사용
- Exception 발생 시, 자동으로 close 메서드 호출
- catch 보다 먼저 실행
- 장점
  - 리소스 누수 방지
  - 모든 리소스가 제대로 닫히도록 보장한다.
  - 코드 간결성 및 가독성 향상
    - 명시적인 close() 호출이 필요 없어 코드가 더 간결하고 읽기 쉬워진다.
  - 스코프 범위 한정
    - 하단의 코드와 같이 try 블럭 안으로 Resource 인서턴스가 한정된다.
  - 더 빠른 자원 해제
   - 기존 : try -> catch -> finally 로 catch 이후에 자원을 반납했다.
   - 변경 : try -> close -> catch 를 호출한다.
```java
public class Main {
    public static void main(String[] args){
        try (Resource resource = new Resource()) {
            throw new RuntimeException();
        }
    }
}
class Resources extends AutoCloseable {
    @Override
    public void close() {
        System.out.println("finally");
    }
}
```