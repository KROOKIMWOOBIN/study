## 다형성
- 부모 타입 하나로 서로 다른 자식 객체를 동일하게 다루는 것

```markdown
Animal animal1 = new Dog();
Animal animal2 = new Cat();
```

### 왜 쓰는가?
1. 구현이 바뀌어도 코드는 안 바뀜
2. 확장에 열려 있고 변경에 닫힌 구조(OCP)
3. 역할(인터페이스/부모) 중심 설계 가능
```markdown
void sound(Animal animal) {
    animal.cry();
}
```
- Dog, Cat, Cow가 추가돼도 → 이 메서드는 수정 없음

## 캐스팅
- 다형성에서는 부모 타입으로 자식을 참조하므로 자식 고유 기능은 바로 접근할 수 없다.

### 업캐스팅(Upcasting)
- 자식 객체를 부모 타입으로 참조하는 것

```markdown
Animal animal = new Dog();
```

#### 특징
- 자동 형변환
- 자식 고유 메서드는 접근 불가능

### 다운캐스팅(Downcasting)
- 부모 타입으로 참조하던 객체를 다시 자식 타입으로 변환

#### 사용 이유
- 자식에 고유 메서드를 사용하고 싶은 경우에 많이 사용된다.

#### 특징
- 자동 형변환 아님
- 실제 객체가 해당 타입이 아니면 `ClassCastException` 발생
```markdown
Animal animal = new Cat();
Dog dog = (Dog) animal; // 런타임 에러
```

#### 안전한 다운캐스팅
- 동물 안에 개가 있는 지 검증
```markdown
if (animal instanceof Dog) {
    Dog dog = (Dog) animal;
    dog.bite();
}
```

## 동적 바인딩
- 메서드 호출 시점에 “객체 기준”으로 실행 메서드가 결정되는 것

### 예제
```java
public class Main {

    public static void main(String[] args) {
        Aniaml animal = new Dog();
        System.out.println(animal.name); // 필드 변수는 동적 바인딩이 대상이 아니다. -> 동물 출력
        animal.sound(); // 메서드는 동적 바인딩 대상이다. -> 멍멍 출력
    }

    private static class Aniaml {
        String name = "동물";
        void sound() {
            System.out.println("동물 소리");
        }
    }

    private static class Dog extends Aniaml {
        String name = "개";
        @Override
        void sound() {
            System.out.println("멍멍");
        }
    }

}
```