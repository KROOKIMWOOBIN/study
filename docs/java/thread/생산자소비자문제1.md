## 생산자 소비자 문제1

### 문제 탄생 배경
- 멀티스레드 환경에서 데이터를 만드는 쪽과 데이터를 쓰는 쪽의 속도가 다를 수 있다.
  - 두 스레드가 같은 자원(버퍼) 을 공유하면 경쟁 상태가 발생한다.
- 목표
  - 데이터 유실 없음
  - CPU 낭비 없음
  - 동기화 보장

### 기본 개념
|명칭| 역할                             | 설명                                              |
|--|--------------------------------|-------------------------------------------------|
|생산자(Producer)| 데이터 생성                         | 버퍼에 데이터를 저장한다.                                  |
|소비자(Consumer)| 데이터 소비                               | 버퍼에 데이터를 꺼낸다.                                   |
|버퍼(Buffer)| 공유 자원 | 버퍼는 한정된 크기를 가지며, 생산자와 소비자가 이 버퍼를 통해 데이터를 주고받는다. |

### 문제 사항
|문제| 상황                                              | 문제                                             | 해결 방안                                          |
|--|-------------------------------------------------|------------------------------------------------|------------------------------------------------|
|생산자가 너무 빠를 때| 버퍼가 가득 차서 더 이상 데이터를 넣을 수 없을 때까지 생산자가 데이터를 생성한다. | 버퍼에 데이터가 가득 찼을 때 넣으면 오버플로우 / 데이터 유실이 발생할 수 있다. | 버퍼가 가득 찬 경우 생산자는 버퍼에 빈 공간이 생길 때까지 기다려야 한다.     |
|소비자가 너무 빠를 때|버퍼가 비어서 더 이상 소비할 데이터가 없을 때까지 소비자가 데이터를 처리한다.| 버퍼에 데이터가 없을 때 소비자가 꺼내려고 시도하면 안 된다.             |  버퍼가 비어있을 때 소비자는 버퍼에 새로운 데이터가 들어올 때까지 기다려야 한다. |

## Object - wait, notify
|메서드| 설명                                                   |
|--|------------------------------------------------------|
|Object.wait()| 현재 스레드가 가진 락을 반납하고 대기하고,<br>해당 스레드는 wait set으로 들어간다. |
|Object.notify()| wait set에 대기 중인 스레드 중 하나를 깨운다.                       |
|Object.notifyAll()| wait set에 대기 중인 모든 스레드를 깨운다.                         |

### 한계
- 비효율
  - 깨워야 할 스레드를 구분해서 깨울 수 없음
  - 잘못 깨우는 경우 발생
    - 소비자 → 소비자
    - 생산자 → 생산자
- 스레드 기아
  - 어떤 스레드가 깨어날지 보장되지 않음
  - 특정 스레드가 계속 밀릴 수 있음
- 임시 해결
  - notifyAll() 문제는 줄어들지만, 컨텍스트 스위칭 비용 증가

### 스레드 대기 집합(wait set)

#### 정의
```markdown
조건이 만족되지 않아 락을 반납하고 대기 중인 스레드들이
객체 상태 변화(notify)를 기다리는 공간이다
```

#### 왜 필요한가?
```markdown
“락을 반납한 채로, 객체의 상태(WAITING)가 바뀔 때까지 CPU를 쓰지 않고 기다리게 하기 위해” 필요하다.
```