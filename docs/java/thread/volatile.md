## 메모리 가시성
- 한 스레드가 변경한 값이 다른 스레드에서 언제, 어떻게 보이느냐의 문제

### 메모리 구조
```markdown
- CPU CORE
    - L1 Cache
    - L2 Cache
    - L3 Cache
- Main Memory (RAM)
```

### 메모리 가시성 왜 발생하냐?
- 각 CPU 코어는 메인 메모리가 아니라 자기 캐시 메모리에 있는 값을 기준으로 실행한다.
- 이 캐시는 성능을 위해 사용되며, 캐시 간 동기화는 즉시 강제되지 않는다.

#### 왜 이렇게 설계 되었는가?
- 메인 메모리는 너무 느리다.
  - RAM 접근: 수백 CPU 사이클

## volatile
- 성능을 포기하는 대신 값을 읽을때, 값을 쓸 때 모두 메인 메모리에 직접 접근하다.

## JMM(Java Memory Model)
- 자바에서 스레드 간 메모리 접근이 어떻게 보이고, 어떤 순서로 보장되는지를 정의한 공식 규칙

### JMM 정의
- 가시성 (Visibility)
  - 값이 다른 스레드에게 보이는가?
- 원자성 (Atomicity)
  - 연산이 쪼개지지 않는가?
- 순서 보장 (Ordering)
  - 코드 작성 순서대로 실행되는가?

## happens-before
- 어떤 쓰기(write)가 다른 읽기(read)보다 먼저 발생했음이 보장되는 관계